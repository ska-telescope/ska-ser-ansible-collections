---
- name: Load default variables
  include_vars:
    file: ../vars/default.yml

- name: resolve platform specific vars
  include_vars: '{{ node_vars }}'
  with_first_found:
    - files:
        - '{{ ansible_distribution }}-{{ ansible_distribution_release }}.yml'
        - '{{ ansible_distribution }}.yml'
        - '{{ ansible_os_family }}.yml'
      errors: ignore
      paths:
        - '{{ role_path }}/../../vars'
        - '{{ role_path }}/vars'
  loop_control:
    loop_var: node_vars

- name: Set hostnames
  hostname:
    name: "{{ inventory_hostname }}"
  when: not inventory_hostname == "localhost" and change_hostnames
  become: true

- name: update /etc/hosts
  lineinfile:
    dest: /etc/hosts
    regexp: '{{ ansible_default_ipv4.address }} .*{{ inventory_hostname }}'
    line: "{{ ansible_default_ipv4.address }} {{ inventory_hostname }}"
    state: present
  when: not inventory_hostname == "localhost"
  register: updatehosts
  become: true

- name: update /etc/hosts others
  lineinfile:
    dest: /etc/hosts
    regexp: '.*{{ hostvars[item].inventory_hostname }}.*'
    line: "{{ hostvars[item].ansible_default_ipv4.address }} {{ hostvars[item].inventory_hostname }}"
    state: present
  with_items: '{{ groups["cluster"] }}'
  when: not item == "localhost"
  register: updatehosts
  become: true

- name: set defaults for volume flags - backwards compatibility
  set_fact:
    calc_create_data_vol: "{{ calc_create_data_vol | default(create_data_vol) }}"
    calc_mount_data_vol: "{{ calc_mount_data_vol | default(mount_data_vol) }}"
    calc_create_data2_vol: "{{ calc_create_data2_vol | default(create_data2_vol) }}"
    calc_mount_data2_vol: "{{ calc_mount_data2_vol | default(mount_data2_vol) }}"

# mount up all the file-systems
- name: Check if /var/lib/docker file-system is already mounted
  command: /bin/mountpoint -q "/var/lib/docker"
  ignore_errors: true
  register: docker_fs_checked
  changed_when: "docker_fs_checked.rc != 0"

- name: First time mount of docker
  block:

    - name: docker_vol device file
      set_fact:
        docker_vol_dev: "/dev/disk/by-id/virtio-{{ hostvars[inventory_hostname].docker_vol_diskid }}"

    - name: Format docker_libs
      filesystem:
        fstype: xfs
        dev: "{{ docker_vol_dev }}"

    - name: "Get UUID for docker_libs partition"
      command: "blkid -s UUID -o value {{ docker_vol_dev }}"
      register: docker_disk_blkid
      changed_when: false

    - name: Creates directory /var/lib/docker
      file:
        path: /var/lib/docker
        state: directory
        mode: "0755"

    - name: mount docker_libs
      mount:
        name: /var/lib/docker
        src: 'UUID={{ docker_disk_blkid.stdout }}'
        opts: defaults,noatime
        dump: "0"
        passno: "0"
        fstype: xfs
        state: mounted
  when: docker_fs_checked.rc != 0 and docker_vol_size > 0

- name: Check if data file-system is already mounted
  command: /bin/mountpoint -q "{{ data_filesystem }}"
  ignore_errors: true
  register: fs_checked
  changed_when: "fs_checked.rc != 0"

- name: First time mount of data
  block:
    - name: data_vol device file
      set_fact:
        data_vol_dev: "/dev/disk/by-id/virtio-{{ hostvars[inventory_hostname].data_vol_diskid }}"

    - name: Format data
      filesystem:
        fstype: xfs
        dev: "{{ data_vol_dev }}"

    - name: "Get UUID for data partition"
      command: "blkid -s UUID -o value {{ data_vol_dev }}"
      register: data_disk_blkid
      changed_when: false

    - name: Creates directory for data
      file:
        path: "{{ data_filesystem }}"
        state: directory
        mode: "0755"

    - name: mount data
      mount:
        name: "{{ data_filesystem }}"
        src: 'UUID={{ data_disk_blkid.stdout }}'
        opts: defaults,noatime
        dump: "0"
        passno: "0"
        fstype: xfs
        state: mounted
  when: not fs_checked.rc == 0 and calc_create_data_vol and calc_mount_data_vol
# create_data_vol is passed to the heat template conditional for creating and
# attaching the data volume
# mount_data_vol is just for deciding whether to mount it or not

- name: Check if data file-system is already mounted
  command: /bin/mountpoint -q "{{ data2_filesystem }}"
  ignore_errors: true
  register: fs_checked
  changed_when: "fs_checked.rc != 0"

- name: First time mount of data2
  block:
    - name: data2_vol device file
      set_fact:
        data2_vol_dev: "/dev/disk/by-id/virtio-{{ hostvars[inventory_hostname].data2_vol_diskid }}"

    - name: Format data2
      filesystem:
        fstype: xfs
        dev: "{{ data2_vol_dev }}"

    - name: "Get UUID for data2 partition"
      command: "blkid -s UUID -o value {{ data2_vol_dev }}"
      register: data2_disk_blkid
      changed_when: false

    - name: Creates directory for data2
      file:
        path: "{{ data2_filesystem }}"
        state: directory
        mode: "0755"

    - name: mount data2
      mount:
        name: "{{ data2_filesystem }}"
        src: 'UUID={{ data2_disk_blkid.stdout }}'
        opts: defaults,noatime
        dump: "0"
        passno: "0"
        fstype: xfs
        state: mounted
  when: not fs_checked.rc == 0 and calc_create_data2_vol and calc_mount_data2_vol

# tidy up from bad previous deployment
# - name: remove references to focal from /etc/apt/sources.list.d/sources.list
#   lineinfile:
#     regexp: " focal"
#     dest: /etc/apt/sources.list.d/sources.list
#     state: absent
#   when: ansible_os_family == "Debian"

- name: Ensure required packages are installed (apt)
  apt:
    name: "{{ common_packages|default([]) }}"
    update_cache: true
    state: present
  register: apt_res
  retries: 30
  delay: 30
  until: apt_res is success
  when: ansible_os_family == "Debian"

- name: Ensure dnf installed
  yum:
    name: "dnf"
    state: present
  when: ansible_distribution == "CentOS"

- name: Ensure required packages are installed (dnf)
  dnf:
    name: "{{ common_packages|default([]) }}"
    state: present
  when: ansible_os_family == "RedHat"

- name: Upgrade all packages (apt)
  apt:
    upgrade: dist
    autoremove: true
  when: ansible_os_family == "Debian"
  register: apt_res
  retries: 30
  delay: 30
  until: apt_res is success

- name: upgrade all packages (dnf)  # noqa package-latest
  dnf:
    name: "*"
    state: latest
  when: ansible_os_family == "RedHat"

- name: "Enable {{ ntp_service }} service"
  service:
    name: "{{ ntp_service }}"
    enabled: true
  when: ntp_apply

- name: Make sure the NTP service is stopped
  service:
    name: "{{ ntp_service }}"
    state: stopped
  when: ntp_apply

- name: Force NTP sync
  command: "{{ ntp_sync }}"
  changed_when: false
  when: ntp_apply

- name: Start the NTP service
  service:
    name: "{{ ntp_service }}"
    state: started
    enabled: true
  when: ntp_apply

- name: Set ulimits limits
  lineinfile: dest=/etc/security/limits.conf
              insertbefore="^# End of file"
              state=present
              line="{{ item }}"
  with_items:
    - "* soft nofile 32768"
    - "* hard nofile 32768"
    - "* soft memlock unlimited"
    - "* hard memlock unlimited"
    - "* soft nproc 65536"
    - "* hard nproc 65536"

- name: Set swappiness to 1
  sysctl:
    name: vm.swappiness
    value: "1"
    state: present
    ignoreerrors: true

- name: Disable Transparent Huge Pages in Grub 2
  lineinfile:
    dest: /etc/default/grub
    state: present
    line: 'GRUB_CMDLINE_LINUX=$GRUB_CMDLINE_LINUX" transparent_hugepage=never"'
  # when: ansible_distribution_major_version|int > 6
  notify: run update-grub

- name: Flush those handlers
  meta: flush_handlers

- name: Disable Transparent Huge Pages until reboot  # noqa ignore-errors
  command: echo never > /sys/kernel/mm/transparent_hugepage/enabled && echo never > /sys/kernel/mm/transparent_hugepage/defrag
  ignore_errors: true
  changed_when: false
